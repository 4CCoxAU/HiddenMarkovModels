---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

# Setup

```{r, setup}
library('pacman')

# Initialisation
p_load(rstan, 
       bayesplot, 
       ggplot2, 
       coda, 
       circular, 
       moveHMM, 
       tidyr, 
       dplyr, 
       patchwork, 
       CircStats)

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
extract <- rstan::extract
pal <- c("firebrick","seagreen","navy") # colour palette
set.seed(1)
```

# State Transitions
```{r}
# Number of states
N <- 2
# transition probabilities
Gamma <- matrix(c(0.9,0.1,0.1,0.9),2,2)
# initial distribution set to the stationary distribution
delta <- solve(t(diag(N)-Gamma +1), rep(1, N)) #This calculates the stationary distribution - in the long run, what proportion of time is spent in each state? The formula solves: δ = δΓ (where δΓ means "δ times Gamma")
# state-dependent Gaussian means
mu <- c(1,5)
nobs <- 1000
S <- rep(NA,nobs)
y <- rep(NA,nobs)
# initialise state and observation
S[1] <- sample(1:N, size=1, prob=delta) # Pick starting state
y[1] <- rnorm(1, mu[S[1]], 2) # Generate first observation
# simulate state and observation processes forward
for(t in 2:nobs) {
  S[t] <- sample(1:N, size=1, prob=Gamma[S[t-1],]) # Transition
  y[t] <- rnorm(1, mu[S[t]], 2) # Observe
}

sim_data <- data.frame(
  time = 1:nobs,           # x-axis: time points
  observation = y,         # y-axis: observed values
  state = factor(S)        # color: hidden state (convert to factor)
)

ggplot(sim_data, aes(x = time, y = observation, color = state)) +
  geom_segment(aes(xend = time, yend = 0), 
               linewidth = 0.8) +  # vertical lines from 0 to observation
  scale_color_manual(values = c("1" = "firebrick", "2" = "seagreen"),
                     labels = c("State 1", "State 2")) +
  labs(title = "Simulated HMM Observations",
       x = "Time",
       y = "Observation Value",
       color = "Hidden State") +
  theme_minimal()

ggplot(sim_data, aes(x = observation, fill = state)) +
  geom_density() +
  scale_fill_manual(values = c("1" = "firebrick", "2" = "seagreen"),
                     labels = c("State 1", "State 2")) +
  labs(title = "Simulated HMM Observations",
       x = "Value",
       y = "Density",
       color = "Hidden State") +
  theme_minimal()
```

# Stan Model
```{r}
stan.data <- list(y = y, T = nobs, N = 2)
fit <- stan(file="HMM_v1.stan", data=stan.data, refresh=2000)

# Extract mu samples
mus <- extract(fit, pars = c("mu"))

# Create tidy data frame
mu_samples <- data.frame(
  mu1 = mus$mu[,1],
  mu2 = mus$mu[,2]
) %>%
  pivot_longer(cols = everything(), 
               names_to = "parameter", 
               values_to = "value")

# Add true values
true_values <- data.frame(
  parameter = c("mu1", "mu2"),
  true_value = c(1, 5)
)

# Plot both parameters
ggplot(mu_samples, aes(x = value, fill = parameter)) +
  geom_histogram(bins = 30, alpha = 0.7, color = "black") +
  geom_vline(data = true_values, 
             aes(xintercept = true_value, color = parameter),
             linewidth = 1.5, linetype = "dashed") +
  facet_wrap(~parameter, scales = "free", 
             labeller = labeller(parameter = c(mu1 = "μ1", mu2 = "μ2"))) +
  scale_fill_manual(values = c("mu1" = "firebrick", "mu2" = "seagreen")) +
  scale_color_manual(values = c("mu1" = "firebrick", "mu2" = "seagreen")) +
  labs(title = "Posterior Distributions of State-Dependent Means",
       x = "Parameter Value",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "none")

psam <- extract(fit, pars = c("theta", "mu"))
n.sims <- dim(psam[[1]])[1]

for (j in 1:n.sims) {
  theta <- psam[[1]][j, , ]        # Get this draw's transition matrix
  statdist <- solve(t(diag(N) - theta + 1), rep(1, N))           # Calculate stationary dist
  ppstates[j, 1] <- sample(1:N, size = 1, prob = statdist)    # Simulate starting state
  ppobs[j, 1] <- rnorm(1, mean = psam[[2]][j, ppstates[j, 1]], sd = 2)        # Generate first observation
  
  for (i in 2:length(y)) {
    ppstates[j, i] <- sample(1:N, size = 1, prob = theta[ppstates[j, i - 1], ]) # Transition to next state
    ppobs[j, i] <- rnorm(1, mean = psam[[2]][j, ppstates[j, i]], sd = 2)      # Generate observation
  }
}

# Prepare data for plotting
# Observed data
obs_data <- data.frame(value = y, type = "observed")

# Simulated data (just first 100 draws to avoid overplotting)
sim_data <- data.frame(
  value = as.vector(t(ppobs[1:100, ])),
  draw = rep(1:100, each = ncol(ppobs)),
  type = "simulated"
)

# Plot
ggplot() +
  # Simulated datasets (light lines)
  geom_density(data = sim_data, 
               aes(x = value, group = draw),
               color = "skyblue", alpha = 0.1, linewidth = 0.2) +
  # Observed data (dark line)
  geom_density(data = obs_data, 
               aes(x = value),
               color = "black", linewidth = 1.2) +
  labs(title = "Posterior Predictive Check: Density Overlay",
       subtitle = "Black = observed data, Blue = simulated datasets from model",
       x = "Observation Value",
       y = "Density") +
  theme_minimal()

oac = acf(y[2:(n - 1)], lag.max = (nlags - 1), plot = FALSE)$acf

for (i in 1:n.sims) {
  ppac[i, ] = acf(ppobs[i, ], lag.max = (nlags - 1), plot = FALSE)$acf
}

hpd.acf <- HPDinterval(as.mcmc(ppac), prob = 0.95)

# Calculate observed ACF
nlags <- 61
oac <- acf(y[2:(n - 1)], lag.max = (nlags - 1), plot = FALSE)$acf

# Calculate ACF for each simulated dataset
ppac <- matrix(NA, n.sims, nlags)

for (i in 1:n.sims) {
  ppac[i, ] <- acf(ppobs[i, ], lag.max = (nlags - 1), plot = FALSE)$acf
}

# Plot with improved styling
ggplot(dat, aes(x = x)) +
  # Credible interval ribbon
  geom_ribbon(aes(ymin = lb, ymax = ub), 
              fill = "skyblue", alpha = 0.5) +
  # Observed ACF line
  geom_line(aes(y = acf), 
            color = "darkblue", linewidth = 1) +
  geom_point(aes(y = acf), 
             color = "darkblue", size = 2) +
  # Reference line at 0
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  coord_cartesian(xlim = c(2, 60), ylim = c(-0.1, 0.5)) +
  labs(title = "Posterior Predictive Check: Autocorrelation Function",
       x = "Lag",
       y = "Autocorrelation") +
  theme_minimal() +
  theme(panel.grid.minor = element_blank())
```

# Transitions with Covariates
```{r}
rawhaggis <- haggis_data
# derive step lengths and turning angles from locations
data <- prepData(rawhaggis, type="UTM")

# Plot 1: Step Lengths
p1 <- ggplot(data, aes(x = step)) +
  geom_histogram(bins = 30, fill = "steelblue", color = "black", alpha = 0.7) +
  labs(title = "Distribution of Step Lengths",
       x = "Step Length (meters)",
       y = "Frequency") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))
print(p1)

# Plot 2: Turning Angles
p2 <- ggplot(data, aes(x = angle)) +
  geom_histogram(breaks = seq(-pi, pi, length.out = 15), 
                 fill = "coral", color = "black", alpha = 0.7) +
  scale_x_continuous(breaks = c(-pi, -pi/2, 0, pi/2, pi),
                     labels = c("-π", "-π/2", "0", "π/2", "π")) +
  labs(title = "Distribution of Turning Angles",
       x = "Turning Angle (radians)",
       y = "Frequency") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))

print(p2)

# Show both plots together
p1 + p2 + 
  plot_annotation(
    title = "Movement Data",
    subtitle = "Step lengths and turning angles derived from GPS locations",
    theme = theme(plot.title = element_text(face = "bold", size = 16))
  )

# set NAs to out-of-range values
data$step[is.na(data$step)] <- -10
data$angle[is.na(data$angle)] <- -10
data$ID <- as.numeric(data$ID)

stan.data <- list(T=nrow(data), ID=data$ID, steps=data$step, angles=data$angle, N=2, nCovs=3, 
                  covs = cbind(1, scale(data$temp), scale(data$slope), scale(data$slope)^2))

inits <- list(list(mu=c(1,5), sigma=c(1,5), xangle=c(-1,3), yangle=c(0,0), beta=matrix(c(-2,-2,0,0,0,0,0,0),nrow=2)), 
              list(mu=c(1,5), sigma=c(1,5), xangle=c(-1,3), yangle=c(0,0), beta=matrix(c(-2,-2,0,0,0,0,0,0),nrow=2)))

fit <- stan(file = "HMM_v2.stan", 
            data = stan.data, 
            iter = 1000, 
            init = inits, 
            control = list(adapt_delta=0.9), 
            chains = 2)

mus <- extract(fit, pars = "mu")

# Create tidy data frame
mu_samples <- data.frame(
  mu1 = mus$mu[,1],
  mu2 = mus$mu[,2]
) %>%
  pivot_longer(cols = everything(), 
               names_to = "parameter", 
               values_to = "value")

# Add true values
true_values <- data.frame(
  parameter = c("mu1", "mu2"),
  true_value = c(1, 5)
)

# Plot both parameters
ggplot(mu_samples, aes(x = value, fill = parameter)) +
  geom_histogram(bins = 30, alpha = 0.7, color = "black") +
  geom_vline(data = true_values, 
             aes(xintercept = true_value, color = parameter),
             linewidth = 1.5, linetype = "dashed") +
  facet_wrap(~parameter, scales = "free", 
             labeller = labeller(parameter = c(mu1 = "μ1", mu2 = "μ2"))) +
  scale_fill_manual(values = c("mu1" = "firebrick", "mu2" = "seagreen")) +
  scale_color_manual(values = c("mu1" = "firebrick", "mu2" = "seagreen")) +
  labs(title = "Posterior Distributions of State-Dependent Means",
       x = "Parameter Value",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "none")

fit

summary(fit, pars = c("shape", "rate", "loc", "kappa"), probs = c(0.05, 0.95))$summary

# restore NAs
data$step[data$step < 0] <- NA
data$angle[data$angle < (-pi)] <- NA
# unpack posterior draws
shape <- extract(fit, pars = "shape")$shape
rate <- extract(fit, pars = "rate")$rate

loc <- extract(fit, pars = "loc")$loc
kappa <- extract(fit, pars = "kappa")$kappa

# indices of posterior draws to plot (thinned for visualisation purposes)
ind <- seq(1, nrow(shape), by = 5)
# plot step length densities

stepgrid <- seq(min(data$step, na.rm = TRUE), max(data$step, na.rm = TRUE),
length = 100)
plot(NA, xlim = c(0, 20), ylim = c(0, 1.1), xlab = "step length", ylab = "density")
for (i in ind) {
  # plot density for each state
  points(stepgrid, dgamma(stepgrid, shape = shape[i, 1], rate = rate[i, 1]), 
         type = "l", lwd = 0.2, col = adjustcolor(pal[1], alpha.f = 0.1))
  points(stepgrid, dgamma(stepgrid, shape = shape[i, 2], rate = rate[i, 2]),
         type = "l", lwd = 0.2, col = adjustcolor(pal[2], alpha.f = 0.1))
}

# plot turning angle densities
anglegrid <- seq(-pi, pi, length = 100)
plot(NA, xlim = c(-pi, pi), ylim = c(0, 1.2), xlab = "turnging angle", ylab = "density")

for (i in ind[-1]) {
  # plot density for each state
  points(anglegrid, dvm(anglegrid, mu = loc[i, 1], kappa = kappa[i, 1]), type = "l", 
         lwd = 0.2, col = adjustcolor(pal[1], alpha.f = 0.1))
  points(anglegrid, dvm(anglegrid, mu = loc[i, 2], kappa = kappa[i, 2]), type = "l",
         lwd = 0.2, col = adjustcolor(pal[2], alpha.f = 0.1))
}




```


